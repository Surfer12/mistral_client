package com.uplift.system.monitoring;

import com.uplift.system.events.DomainAwareEventBus.Domain;
import com.uplift.system.config.SystemConfig;
import com.uplift.system.adapters.DomainAwareAdapter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.Executors;
import java.time.Instant;
import java.util.function.Consumer;
import com.uplift.system.monitoring.models.Metric;
import com.uplift.system.monitoring.exceptions.MetricCollectionException;
import org.jetbrains.annotations.NotNull;
import java.time.Duration;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Service for monitoring and visualizing domain integration metrics
 */
public class DomainMonitoringService extends AbstractDomainMonitor {
    private static final Logger LOG = Logger.getLogger(DomainMonitoringService.class.getName());
    private final SystemConfig config;
    private final Map<String, MetricCollector> metricCollectors;
    private final Map<String, List<MetricSnapshot>> metricHistory;
    private final ScheduledExecutorService scheduler;
    private final Map<Domain, DomainAwareAdapter> domainAdapters;
    private final List<Consumer<Map<String, Object>>> visualizationListeners;
    private final Map<String, AlertThreshold> alertThresholds;
    private final List<Consumer<Alert>> alertListeners;
    
    private ScheduledFuture<?> collectionTask;
    private ScheduledFuture<?> visualizationTask;

    /**
     * Represents an alert threshold configuration.
     */
    public static class AlertThreshold {
        private final String metricName;
        private final double threshold;
        private final Duration window;
        private final AlertType type;

        public AlertThreshold(String metricName, double threshold, Duration window, AlertType type) {
            this.metricName = metricName;
            this.threshold = threshold;
            this.window = window;
            this.type = type;
        }
    }

    /**
     * Represents different types of alerts.
     */
    public enum AlertType {
        THRESHOLD_EXCEEDED,
        RATE_OF_CHANGE,
        ANOMALY_DETECTED
    }

    /**
     * Represents an alert generated by the monitoring service.
     */
    public static class Alert {
        private final String domain;
        private final String metricName;
        private final AlertType type;
        private final double value;
        private final double threshold;
        private final Instant timestamp;

        public Alert(String domain, String metricName, AlertType type, 
                    double value, double threshold) {
            this.domain = domain;
            this.metricName = metricName;
            this.type = type;
            this.value = value;
            this.threshold = threshold;
            this.timestamp = Instant.now();
        }

        // Getters
        public String getDomain() { return domain; }
        public String getMetricName() { return metricName; }
        public AlertType getType() { return type; }
        public double getValue() { return value; }
        public double getThreshold() { return threshold; }
        public Instant getTimestamp() { return timestamp; }
    }

    public DomainMonitoringService(@NotNull SystemConfig config) {
        super("DomainMonitoringService");
        this.config = Objects.requireNonNull(config, "Config must not be null");
        this.metricCollectors = new ConcurrentHashMap<>();
        this.metricHistory = new ConcurrentHashMap<>();
        this.scheduler = Executors.newScheduledThreadPool(2);
        this.domainAdapters = new EnumMap<>(Domain.class);
        this.visualizationListeners = new ArrayList<>();
        this.alertThresholds = new HashMap<>();
        this.alertListeners = new ArrayList<>();
        
        initializeCollectors();
        initializeScheduledTasks();
    }

    private void initializeCollectors() {
        // Domain-specific metrics
        for (Domain domain : Domain.values()) {
            String collectorId = domain.toString().toLowerCase() + "_metrics";
            metricCollectors.put(collectorId, new MetricCollector(
                collectorId,
                () -> collectDomainMetrics(domain)
            ));
        }

        // Integration metrics
        metricCollectors.put("integration_metrics", new MetricCollector(
            "integration_metrics",
            this::collectIntegrationMetrics
        ));

        // Isomorphic structure metrics
        metricCollectors.put("isomorphic_metrics", new MetricCollector(
            "isomorphic_metrics",
            this::collectIsomorphicMetrics
        ));

        // System-wide metrics
        metricCollectors.put("system_metrics", new MetricCollector(
            "system_metrics",
            this::collectSystemMetrics
        ));
    }

    public void registerDomainAdapter(Domain domain, DomainAwareAdapter adapter) {
        domainAdapters.put(domain, adapter);
    }

    public void addVisualizationListener(Consumer<Map<String, Object>> listener) {
        visualizationListeners.add(listener);
    }

    public void startMonitoring() {
        long metricsInterval = config.getSetting("monitoring.metricsInterval", 30000L);
        long visualizationInterval = config.getSetting("monitoring.visualizationInterval", 5000L);

        // Start metric collection
        collectionTask = scheduler.scheduleAtFixedRate(
            this::collectMetrics,
            0,
            metricsInterval,
            TimeUnit.MILLISECONDS
        );

        // Start visualization updates
        visualizationTask = scheduler.scheduleAtFixedRate(
            this::updateVisualizations,
            0,
            visualizationInterval,
            TimeUnit.MILLISECONDS
        );
    }

    public void stopMonitoring() {
        if (collectionTask != null) {
            collectionTask.cancel(false);
        }
        if (visualizationTask != null) {
            visualizationTask.cancel(false);
        }
    }

    private void collectMetrics() {
        metricCollectors.values().forEach(collector -> {
            Map<String, Object> metrics = collector.collect();
            MetricSnapshot snapshot = new MetricSnapshot(
                collector.getId(),
                Instant.now(),
                metrics
            );
            metricHistory.computeIfAbsent(collector.getId(), k -> new ArrayList<>())
                        .add(snapshot);
            
            // Keep history size manageable
            int maxHistory = config.getSetting("monitoring.maxHistorySize", 1000);
            List<MetricSnapshot> history = metricHistory.get(collector.getId());
            if (history.size() > maxHistory) {
                history.subList(0, history.size() - maxHistory).clear();
            }
        });
    }

    private void updateVisualizations() {
        Map<String, Object> visualizationData = new HashMap<>();
        
        // Prepare domain metrics visualization
        Map<String, Object> domainMetrics = new HashMap<>();
        domainAdapters.forEach((domain, adapter) -> {
            domainMetrics.put(domain.toString(), adapter.getDomainMetrics(domain));
        });
        visualizationData.put("domains", domainMetrics);
        
        // Prepare integration metrics
        visualizationData.put("integration", collectIntegrationMetrics());
        
        // Prepare isomorphic metrics
        visualizationData.put("isomorphic", collectIsomorphicMetrics());
        
        // Prepare historical trends
        visualizationData.put("trends", calculateMetricTrends());
        
        // Notify listeners
        visualizationListeners.forEach(listener -> listener.accept(visualizationData));
    }

    private Map<String, Object> collectDomainMetrics(Domain domain) {
        DomainAwareAdapter adapter = domainAdapters.get(domain);
        if (adapter == null) {
            return Collections.emptyMap();
        }
        
        Map<String, Object> metrics = new HashMap<>(adapter.getDomainMetrics(domain));
        metrics.put("optimizationStrategy", adapter.getDomainOptimizationStrategy(domain));
        return metrics;
    }

    private Map<String, Object> collectIntegrationMetrics() {
        Map<String, Object> metrics = new HashMap<>();
        
        // Collect transformation counts and performance metrics
        metrics.put("transformationCount", calculateTransformationCount());
        metrics.put("averageTransformationTime", calculateAverageTransformationTime());
        metrics.put("successRate", calculateTransformationSuccessRate());
        
        return metrics;
    }

    private Map<String, Object> collectIsomorphicMetrics() {
        Map<String, Object> metrics = new HashMap<>();
        
        // Collect metrics for each isomorphic structure
        metrics.put("recursion", collectStructureMetrics("recursion"));
        metrics.put("compression", collectStructureMetrics("compression"));
        metrics.put("metaObservation", collectStructureMetrics("meta_observation"));
        
        return metrics;
    }

    private Map<String, Object> collectSystemMetrics() {
        Map<String, Object> metrics = new HashMap<>();
        
        // Collect system-wide performance metrics
        metrics.put("memoryUsage", Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory());
        metrics.put("availableProcessors", Runtime.getRuntime().availableProcessors());
        metrics.put("uptime", ManagementFactory.getRuntimeMXBean().getUptime());
        
        return metrics;
    }

    private Map<String, Object> collectStructureMetrics(String structureId) {
        Map<String, Object> metrics = new HashMap<>();
        
        // Get historical data for this structure
        List<MetricSnapshot> history = metricHistory.getOrDefault(
            "isomorphic_metrics",
            Collections.emptyList()
        );
        
        if (!history.isEmpty()) {
            MetricSnapshot latest = history.get(history.size() - 1);
            @SuppressWarnings("unchecked")
            Map<String, Object> structureMetrics = (Map<String, Object>) latest.getMetrics()
                .getOrDefault(structureId, Collections.emptyMap());
            metrics.putAll(structureMetrics);
        }
        
        return metrics;
    }

    private Map<String, List<Double>> calculateMetricTrends() {
        Map<String, List<Double>> trends = new HashMap<>();
        
        metricHistory.forEach((collectorId, snapshots) -> {
            if (!snapshots.isEmpty()) {
                // Calculate trends for numeric metrics
                MetricSnapshot latest = snapshots.get(snapshots.size() - 1);
                latest.getMetrics().forEach((metricName, value) -> {
                    if (value instanceof Number) {
                        List<Double> trend = calculateTrendForMetric(collectorId, metricName);
                        trends.put(collectorId + "." + metricName, trend);
                    }
                });
            }
        });
        
        return trends;
    }

    private List<Double> calculateTrendForMetric(String collectorId, String metricName) {
        List<MetricSnapshot> snapshots = metricHistory.get(collectorId);
        List<Double> trend = new ArrayList<>();
        
        snapshots.forEach(snapshot -> {
            Object value = snapshot.getMetrics().get(metricName);
            if (value instanceof Number) {
                trend.add(((Number) value).doubleValue());
            }
        });
        
        return trend;
    }

    private long calculateTransformationCount() {
        return metricHistory.values().stream()
            .flatMap(List::stream)
            .filter(snapshot -> snapshot.getId().equals("integration_metrics"))
            .mapToLong(snapshot -> ((Number) snapshot.getMetrics()
                .getOrDefault("transformationCount", 0L)).longValue())
            .sum();
    }

    private double calculateAverageTransformationTime() {
        List<MetricSnapshot> snapshots = metricHistory.getOrDefault(
            "integration_metrics",
            Collections.emptyList()
        );
        
        if (snapshots.isEmpty()) {
            return 0.0;
        }
        
        return snapshots.stream()
            .mapToDouble(snapshot -> ((Number) snapshot.getMetrics()
                .getOrDefault("averageTransformationTime", 0.0)).doubleValue())
            .average()
            .orElse(0.0);
    }

    private double calculateTransformationSuccessRate() {
        List<MetricSnapshot> snapshots = metricHistory.getOrDefault(
            "integration_metrics",
            Collections.emptyList()
        );
        
        if (snapshots.isEmpty()) {
            return 1.0;
        }
        
        long successful = snapshots.stream()
            .mapToLong(snapshot -> ((Number) snapshot.getMetrics()
                .getOrDefault("successfulTransformations", 0L)).longValue())
            .sum();
            
        long total = snapshots.stream()
            .mapToLong(snapshot -> ((Number) snapshot.getMetrics()
                .getOrDefault("totalTransformations", 0L)).longValue())
            .sum();
            
        return total > 0 ? (double) successful / total : 1.0;
    }

    // Inner classes
    private static class MetricCollector {
        private final String id;
        private final MetricSupplier supplier;

        MetricCollector(String id, MetricSupplier supplier) {
            this.id = id;
            this.supplier = supplier;
        }

        String getId() {
            return id;
        }

        Map<String, Object> collect() {
            return supplier.get();
        }
    }

    private static class MetricSnapshot {
        private final String id;
        private final Instant timestamp;
        private final Map<String, Object> metrics;

        MetricSnapshot(String id, Instant timestamp, Map<String, Object> metrics) {
            this.id = id;
            this.timestamp = timestamp;
            this.metrics = new HashMap<>(metrics);
        }

        String getId() {
            return id;
        }

        Instant getTimestamp() {
            return timestamp;
        }

        Map<String, Object> getMetrics() {
            return Collections.unmodifiableMap(metrics);
        }
    }

    @FunctionalInterface
    private interface MetricSupplier {
        Map<String, Object> get();
    }

    /**
     * Adds an alert threshold for monitoring.
     */
    public void addAlertThreshold(@NotNull String domain, @NotNull AlertThreshold threshold) {
        Objects.requireNonNull(domain, "Domain must not be null");
        Objects.requireNonNull(threshold, "Threshold must not be null");
        
        String key = domain + ":" + threshold.metricName;
        alertThresholds.put(key, threshold);
    }

    /**
     * Adds a listener for alerts.
     */
    public void addAlertListener(@NotNull Consumer<Alert> listener) {
        Objects.requireNonNull(listener, "Listener must not be null");
        alertListeners.add(listener);
    }

    @Override
    protected void validateMetric(@NotNull Metric metric) {
        Objects.requireNonNull(metric, "Metric must not be null");
        
        if (metric.getName() == null || metric.getName().isEmpty()) {
            throw new MetricCollectionException("Metric name cannot be null or empty");
        }
        
        if (metric.getValue() == null) {
            throw new MetricCollectionException("Metric value cannot be null");
        }
        
        if (metric.getDomain() == null || metric.getDomain().isEmpty()) {
            throw new MetricCollectionException("Metric domain cannot be null or empty");
        }
    }

    @Override
    protected Metric preprocessMetric(@NotNull Metric metric) {
        // Add system-level tags
        return new Metric.Builder()
            .name(metric.getName())
            .value(metric.getValue())
            .type(metric.getType())
            .timestamp(metric.getTimestamp())
            .domain(metric.getDomain())
            .addTag("host", getHostName())
            .addTag("service", monitorName)
            .build();
    }

    private void initializeScheduledTasks() {
        // Schedule regular metric aggregation
        scheduler.scheduleAtFixedRate(
            this::aggregateMetrics,
            0,
            config.getIntValue("monitoring.aggregation.interval", 60),
            TimeUnit.SECONDS
        );

        // Schedule alert checking
        scheduler.scheduleAtFixedRate(
            this::checkAlertThresholds,
            0,
            config.getIntValue("monitoring.alert.interval", 30),
            TimeUnit.SECONDS
        );
    }

    private void aggregateMetrics() {
        try {
            for (Map.Entry<String, List<Metric>> entry : metricsByDomain.entrySet()) {
                String domain = entry.getKey();
                List<Metric> metrics = entry.getValue();
                
                // Calculate aggregates for the domain
                Map<String, DoubleSummaryStatistics> stats = new HashMap<>();
                
                for (Metric metric : metrics) {
                    if (metric.getValue() instanceof Number) {
                        String name = metric.getName();
                        stats.computeIfAbsent(name, k -> new DoubleSummaryStatistics())
                             .accept(((Number) metric.getValue()).doubleValue());
                    }
                }
                
                // Record aggregated metrics
                for (Map.Entry<String, DoubleSummaryStatistics> stat : stats.entrySet()) {
                    DoubleSummaryStatistics dss = stat.getValue();
                    recordAggregatedMetrics(domain, stat.getKey(), dss);
                }
            }
        } catch (Exception e) {
            LOG.log(Level.SEVERE, "Error during metric aggregation", e);
        }
    }

    private void recordAggregatedMetrics(String domain, String metricName, DoubleSummaryStatistics stats) {
        // Record various aggregated metrics
        recordMetric(new Metric.Builder()
            .name(metricName + ".avg")
            .value(stats.getAverage())
            .type(Metric.MetricType.GAUGE)
            .domain(domain)
            .addTag("aggregation", "avg")
            .build());

        recordMetric(new Metric.Builder()
            .name(metricName + ".max")
            .value(stats.getMax())
            .type(Metric.MetricType.GAUGE)
            .domain(domain)
            .addTag("aggregation", "max")
            .build());

        recordMetric(new Metric.Builder()
            .name(metricName + ".min")
            .value(stats.getMin())
            .type(Metric.MetricType.GAUGE)
            .domain(domain)
            .addTag("aggregation", "min")
            .build());
    }

    private void checkAlertThresholds() {
        try {
            for (Map.Entry<String, AlertThreshold> entry : alertThresholds.entrySet()) {
                String[] parts = entry.getKey().split(":");
                String domain = parts[0];
                AlertThreshold threshold = entry.getValue();
                
                List<Metric> metrics = getMetricsForDomain(domain);
                checkThreshold(domain, metrics, threshold);
            }
        } catch (Exception e) {
            LOG.log(Level.SEVERE, "Error checking alert thresholds", e);
        }
    }

    private void checkThreshold(String domain, List<Metric> metrics, AlertThreshold threshold) {
        // Filter metrics by name and time window
        Instant cutoff = Instant.now().minus(threshold.window);
        List<Metric> relevantMetrics = metrics.stream()
            .filter(m -> m.getName().equals(threshold.metricName))
            .filter(m -> m.getTimestamp().isAfter(cutoff))
            .toList();

        if (relevantMetrics.isEmpty()) {
            return;
        }

        // Calculate the value to check against the threshold
        double value = calculateMetricValue(relevantMetrics, threshold.type);
        
        if (value > threshold.threshold) {
            Alert alert = new Alert(domain, threshold.metricName, threshold.type, value, threshold.threshold);
            notifyAlertListeners(alert);
        }
    }

    private double calculateMetricValue(List<Metric> metrics, AlertType type) {
        switch (type) {
            case THRESHOLD_EXCEEDED:
                return metrics.stream()
                    .mapToDouble(m -> ((Number) m.getValue()).doubleValue())
                    .max()
                    .orElse(0.0);
                
            case RATE_OF_CHANGE:
                if (metrics.size() < 2) return 0.0;
                Metric first = metrics.get(0);
                Metric last = metrics.get(metrics.size() - 1);
                double valueDiff = ((Number) last.getValue()).doubleValue() - 
                                 ((Number) first.getValue()).doubleValue();
                double timeDiff = Duration.between(first.getTimestamp(), last.getTimestamp())
                                        .toSeconds();
                return valueDiff / timeDiff;
                
            case ANOMALY_DETECTED:
                // Simple anomaly detection using z-score
                double mean = metrics.stream()
                    .mapToDouble(m -> ((Number) m.getValue()).doubleValue())
                    .average()
                    .orElse(0.0);
                double stdDev = calculateStdDev(metrics, mean);
                double latest = ((Number) metrics.get(metrics.size() - 1).getValue()).doubleValue();
                return Math.abs(latest - mean) / stdDev;
                
            default:
                return 0.0;
        }
    }

    private double calculateStdDev(List<Metric> metrics, double mean) {
        return Math.sqrt(metrics.stream()
            .mapToDouble(m -> {
                double diff = ((Number) m.getValue()).doubleValue() - mean;
                return diff * diff;
            })
            .average()
            .orElse(0.0));
    }

    private void notifyAlertListeners(Alert alert) {
        for (Consumer<Alert> listener : alertListeners) {
            try {
                listener.accept(alert);
            } catch (Exception e) {
                LOG.log(Level.SEVERE, "Error notifying alert listener", e);
            }
        }
    }

    private String getHostName() {
        try {
            return java.net.InetAddress.getLocalHost().getHostName();
        } catch (Exception e) {
            return "unknown-host";
        }
    }

    /**
     * Shuts down the monitoring service and its scheduled tasks.
     */
    public void shutdown() {
        scheduler.shutdown();
        try {
            if (!scheduler.awaitTermination(60, TimeUnit.SECONDS)) {
                scheduler.shutdownNow();
            }
        } catch (InterruptedException e) {
            scheduler.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }
} 